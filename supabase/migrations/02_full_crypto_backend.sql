-- ============================================================
-- Retatrutide Landing - Crypto & Fulfilment Database Schema
-- Focus: Privacy, Crypto-only payments, Order fulfillment
-- ============================================================

-- =========================
-- ORDERS TABLE
-- =========================
-- Drop existing (assuming you're recreating in dev)
-- DROP TABLE IF EXISTS public.orders CASCADE;

CREATE TABLE IF NOT EXISTS public.orders (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,

    -- Identity & Tracking Analytics
    reference_id VARCHAR NOT NULL UNIQUE, -- Unique ID generated by our backend
    
    -- Status
    status VARCHAR NOT NULL DEFAULT 'pending', -- pending, paid, shipped, cancelled, failed

    -- Payment Details (Crypto Native)
    crypto_currency VARCHAR,     -- BTC, XMR, USDT, ETH, etc.
    crypto_amount DECIMAL,       -- Expected crypto amount
    fiat_amount DECIMAL NOT NULL,  -- Fiat value equivalent at checkout (EUR/USD)
    payment_url VARCHAR,         -- CryptAPI address or QR link

    -- Customer & Shipping Details
    email VARCHAR,               -- Optional, for order tracking updates
    shipping_address JSONB,      -- Contains: { name, line1, line2, city, postal_code, country, phone }
    
    -- Order Details
    items JSONB,                 -- Contains array of product definitions, e.g [{ sku, name, quantity }]
    
    -- Fulfillment & Logistics
    tracking_number VARCHAR,
    carrier VARCHAR,
    shipped_at TIMESTAMP WITH TIME ZONE,
    shipped_by UUID REFERENCES auth.users(id) -- Reference to the admin/warehouse user who shipped it
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_orders_reference_id ON public.orders(reference_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON public.orders(created_at DESC);

-- =========================
-- INVENTORY TABLE
-- =========================
CREATE TABLE IF NOT EXISTS public.inventory (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sku VARCHAR UNIQUE NOT NULL,
    name VARCHAR NOT NULL,
    quantity INTEGER DEFAULT 0,
    reorder_level INTEGER DEFAULT 50,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =========================
-- PROFILES TABLE (RBAC per Admin Dashboard)
-- =========================
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    email VARCHAR NOT NULL,
    full_name VARCHAR,
    role VARCHAR NOT NULL DEFAULT 'warehouse' CHECK (role IN ('super_admin', 'warehouse')),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =========================
-- INITIAL DATA
-- =========================
INSERT INTO public.inventory (sku, name, quantity, reorder_level)
VALUES ('RET-KIT-1', 'Retatrutide Research Kit (Singolo)', 100, 20)
ON CONFLICT (sku) DO NOTHING;

-- =========================
-- ENABLE RLS (Row Level Security)
-- =========================
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- =========================
-- HELPER FUNCTIONS FOR RLS
-- =========================
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS VARCHAR AS $$
BEGIN
    RETURN COALESCE(
        current_setting('request.jwt.claims', true)::json->'app_metadata'->>'role',
        'warehouse' 
    );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_staff()
RETURNS BOOLEAN AS $$
BEGIN
    -- Both super_admin and warehouse are considered staff
    RETURN get_my_role() IN ('super_admin', 'warehouse');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Auto-create profile on new user signup (Admin/Warehouse accounts)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, email, full_name, role)
    VALUES (
        new.id,
        new.email,
        COALESCE(new.raw_user_meta_data->>'full_name', ''),
        COALESCE(new.raw_app_meta_data->>'role', 'warehouse') -- Default new users to warehouse
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop trigger if it exists from previous tests and re-attach
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- =========================
-- RLS POLICIES
-- =========================

-- ORDERS POLICIES
-- 1. Anyone (anonymous checkout) can insert an order securely
CREATE POLICY "Enable insert for checkout flow" 
    ON public.orders FOR INSERT 
    WITH CHECK (true);

-- 2. Anyone (anonymous frontend polling) can read an order IF they know the exact reference_id
CREATE POLICY "Enable select for users based on reference_id" 
    ON public.orders FOR SELECT 
    USING (true);

-- 3. Staff (Admin/Warehouse) can update orders (e.g. Set tracking number)
CREATE POLICY "Staff can update orders"
    ON public.orders FOR UPDATE
    TO authenticated
    USING (is_staff());

-- 4. Service Role (Server API/Webhook) has full access
CREATE POLICY "Service role has full access to orders"
    ON public.orders
    TO service_role
    USING (true)
    WITH CHECK (true);

-- INVENTORY POLICIES
-- 1. Everyone can read inventory (e.g. frontend checking "only 5 left!")
CREATE POLICY "Enable read access for all users"
    ON public.inventory FOR SELECT
    USING (true);

-- 2. Service role / Webhook can update inventory
CREATE POLICY "Service role can update inventory"
    ON public.inventory FOR UPDATE
    TO service_role
    USING (true);

-- 3. Staff can update inventory manually via Admin dashboard
CREATE POLICY "Staff can update inventory manually"
    ON public.inventory FOR UPDATE
    TO authenticated
    USING (is_staff());

-- PROFILES POLICIES
-- 1. Users can read their own profile
CREATE POLICY "Users can read own profile"
    ON public.profiles FOR SELECT
    TO authenticated
    USING (id = auth.uid());

-- 2. Staff can read all profiles (useful for assigning orders)
CREATE POLICY "Staff can read all profiles"
    ON public.profiles FOR SELECT
    TO authenticated
    USING (is_staff());

-- 3. Super Admin can manage (update/insert) profiles
CREATE POLICY "Super admin can update profiles"
    ON public.profiles FOR UPDATE
    TO authenticated
    USING (get_my_role() = 'super_admin');
